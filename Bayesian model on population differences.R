##This script runs a Bayesian model to find estimates of the effects of parentage on larval response to turbulence
##This experiment crossed Dendraster males and females of different populations and examined their offspring response to turbulence
##The response variable of interest in the proportion of larvae settled as a function of turbulence intensity and parenthood
data=read.csv('Full population data.csv')
head(data)
data$dpf=as.factor(data$dpf)
data$rep=as.factor(data$rep)
str(data)
data=data[data$cross!='MExOL',]
library(lme4)

#Creates indices of 1,0 for categorical variables
data$mo.umc=ifelse(data$pop.treat=='moclips.umc', 1, 0)
data$mo.500=ifelse(data$pop.treat=='moclips.500', 1, 0)
data$orc.500=ifelse(data$pop.treat=='orcas.500', 1, 0)
data$orc.umc=ifelse(data$pop.treat=='orcas.umc', 1, 0)
data$hyb.500=ifelse(data$pop.treat=='zhybrid.500', 1, 0)
data$hyb.umc=ifelse(data$pop.treat=='zhybrid.umc', 1, 0)

#This glmer model mimics the Bayesian model that will later be run and is used as a way to double check that the estimates generated by the Bayesian model are reasonable
data.glmer=glmer(cbind(success, fail)~pop.treat+(1|dpf)+(1|rep)+(1|male)+(1|female)-1, control=glmerControl(optimizer='bobyqa', optCtrl=list(maxfun=2e5)),data=data, family=binomial)
summary(data.glmer) 

#Running contrasts to determine the effects different populations have on larval settlement
library(multcomp)
contr=rbind('moclip vs orcas'=c(1,-1,-1,1,0,0),
					'moclip vs hybrid'=c(1,-1,0,0,-1,1),
					'orcas vs hybrid'=c(0,0,1,-1,-1,1)
					)
comps=glht(data.glmer, contr)
summary(comps)

#Creating the Bayesian model in R2jags
library(rjags); library(R2jags); library(bayesplot)
library(MCMCpack); library(lattice); library(dplyr)

pop.jags2=
'model{
	#Likelihood: the following equation shows how the proportion of larvae settled (after a logit transformation) is predicted by the three different crossings of population moclip, population orcas, and the hybrid crossings. Females/males/rep/dpf are added as random effects i.e. hierarchical model
	for(i in 1:n){
		y[i]~dbern(p[i])
		logit(p[i])=b.mo.umc*mo.umc[i]+b.mo.500*mo.500[i]+b.orc.umc*orc.umc[i]+b.orc.500*orc.500[i]+b.hyb.umc*hyb.umc[i]+b.hyb.500*hyb.500[i]+rep[rep.index[i]]+dpf[dpf.index[i]]+females[females.index[i]]+males[males.index[i]]
	}
	
	#Random effects model
	for(j in 1:n.females)
	{
		females[j]~dnorm(0, tau.females) #Model assumes that the mean effect of parentage sums up to 0
	}
	
	for(m in 1:n.males)
	{
		males[m]~dnorm(0, tau.males)
	}
	
	for(k in 1:n.rep)
	{
		rep[k]~dnorm(0, tau.rep)
	}
	
	for(l in 1:n.dpf)
	{
		dpf[l]~dnorm(0, tau.dpf)
	}
	
	#Priors for fixed effect parameters in model
b.mo.umc~dnorm(0, 0.001)
b.mo.500~dnorm(0, 0.001)
b.orc.umc~dnorm(0, 0.001)
b.orc.500~dnorm(0, 0.001)
b.hyb.umc~dnorm(0, 0.001)
b.hyb.500~dnorm(0, 0.001)

##Priors for random effects
#for female intercept
sigma.females~dt(0, pow(2.5, -2),1)T(0,) #A half cauchy distribution was used for the variance prior
tau.females=pow(sigma.females, -2)

#for males
sigma.males~dt(0, pow(2.5, -2),1)T(0,)
tau.males=pow(sigma.males, -2)

#for rep
# sigma.rep~dunif(0, 20)
sigma.rep~dt(0, pow(2.5, -2),1)T(0,)
tau.rep=pow(sigma.rep, -2)

#for dpf
# sigma.dpf~dunif(0, 20)
sigma.dpf~dt(0, pow(2.5, -2),1)T(0,)
tau.dpf=pow(sigma.dpf, -2)

##Differences: calculate the effect of turbulence for each population
orc=(b.orc.500-b.orc.umc)
mo=(b.mo.500-b.mo.umc)
hyb=(b.hyb.500-b.hyb.umc)

#Comparisons: calculate the interactive effects of turbulence and population
mo.orc=(b.mo.500-b.mo.umc)-(b.orc.500-b.orc.umc)
mo.hyb=(b.mo.500-b.mo.umc)-(b.hyb.500-b.hyb.umc)
orc.hyb=(b.orc.500-b.orc.umc)-(b.hyb.500-b.hyb.umc)

##Calculate the overall effect of parentage
mu.fem=mean(females)
mu.rep=mean(rep)
mu.males=mean(males)
mu.dpf=mean(dpf)

#Adds the effects of the different random effects to the population effects. In theory, the mean of the random effects should be zero and not alter the population effects much, but because the estimates for each parameter are correlated, they needed to be summed up to lower the variance of the true effect of population
t.mo.umc=b.mo.umc+mu.fem+mu.rep+mu.males+mu.dpf
t.mo.500=b.mo.500+mu.fem+mu.rep+mu.males+mu.dpf
t.orc.umc=b.orc.umc+mu.fem+mu.rep+mu.males+mu.dpf
t.orc.500=b.orc.500+mu.fem+mu.rep+mu.males+mu.dpf
t.hyb.umc=b.hyb.umc+mu.fem+mu.rep+mu.males+mu.dpf
t.hyb.500=b.hyb.500+mu.fem+mu.rep+mu.males+mu.dpf

t.mo=t.mo.500-t.mo.umc
t.orc=t.orc.500-t.orc.umc
t.hyb=t.hyb.500-t.hyb.umc

t.mo.orc=t.mo-t.orc
t.mo.hyb=t.mo-t.hyb
t.orc.hyb=t.orc-t.hyb
}'

sink('pop.jags2')
cat(pop.jags2)
sink()


pop.parallel2=jags.parallel(data=jags.data, parameters.to.save=c('b.mo.umc', 'b.mo.500', 'b.orc.umc', 'b.orc.500', 'b.hyb.umc', 'b.hyb.500', 'mo.orc', 'mo.hyb', 'orc.hyb', 'orc', 'mo','hyb','males','females', 'mu.fem','mu.rep','mu.males','mu.dpf','t.mo.umc','t.mo.500','t.orc.umc','t.orc.500','t.hyb.umc','t.hyb.500', 't.mo', 't.orc','t.hyb','t.mo.orc','t.mo.hyb','t.orc.hyb','rep','males','females','dpf'), n.iter=50000, model.file='pop.jags2', n.chains=3, n.burnin=10000, DIC=F) #Runs the jags model with 3 chains and 50000 iterations. Takes roughly 10 minutes to run with these parameters
pop.parallel2
plot(pop.parallel2)

#Diagnostic plots of the jags output to ensure that the chains are truly mixing
pop.parallel2.mcmc=as.mcmc(pop.parallel2)
plot(pop.parallel2.mcmc)
traceplot(pop.parallel2.mcmc)
par(mfrow=c(5,5)) 
densplot(pop.parallel2.mcmc[,26:50])
acfplot(pop.parallel2.mcmc)
summary(pop.parallel2.mcmc)

##Saves the output of the jags model
# load('~/Dropbox/Projects/Turbulent shear genetics and exposure and perdurance/Final stats/pop.parallel2.rda')
# save(pop.parallel2.mcmc, file='pop.parallel2.rda')

#Plot
mcmc_intervals(pop.parallel2.mcmc, pars=c('t.hyb.500', 't.hyb.umc', 't.mo.500', 't.mo.umc', 't.orc.500', 't.orc.umc', 't.mo.orc', 't.mo.hyb', 't.orc.hyb'), prob=0.95, prob_outer=0.95)

##Quantiles
t.mo.orc=c(pop.parallel2.mcmc[[1]][,'t.mo.orc'], pop.parallel2.mcmc[[2]][,'t.mo.orc'], pop.parallel2.mcmc[[3]][,'t.mo.orc'])
quantile(t.mo.orc,  probs=seq(0, 1, 0.001)) #99.9

t.orc.hyb=c(pop.parallel2.mcmc[[1]][,'t.orc.hyb'], pop.parallel2.mcmc[[2]][,'t.orc.hyb'], pop.parallel2.mcmc[[3]][,'t.orc.hyb'])
quantile(t.orc.hyb,  probs=seq(0, 1, 0.001)) #94.0

t.mo.hyb=c(pop.parallel2.mcmc[[1]][,'t.mo.hyb'], pop.parallel2.mcmc[[2]][,'t.mo.hyb'], pop.parallel2.mcmc[[3]][,'t.mo.hyb'])
quantile(t.mo.hyb,  probs=seq(0, 1, 0.001)) #90.2

